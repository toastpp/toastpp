<html>
<head>
<title>TOAST Tutorial - Step 1</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<LINK REL="stylesheet" HREF="toast.css" TYPE="TEXT/CSS">
<LINK REL="stylesheet" HREF="demo.css" TYPE="TEXT/CSS">
</head>

<body>
<body>
<div class="header">
   <div class="left"><a href="matlab:edit toast_tut1">Open source in the editor</a></div>
   <div class="right"><a href="matlab:rundemo('toast_tut1')">Run this tutorial</a></div>
</div>

<div class="content">
<div class="navbar">
<a href="toast.html">TOAST</a> &gt;
<a href="matlab:demo toolbox toast">Demos</a> &gt;
Tutorial 1
</div>

<h1>TOAST Tutorial 1: A simple absorption reconstruction</h1>
<p><i>To follow the code of this tutorial step by step, open the Matlab script
by clicking the "Open source" link above, and evaluate line by line, or by
setting appropriate breakpoints.</i>

<p>This tutorial sets up a simple absorption reconstruction problem from 
CW (continuous wave) boundary data. It introduces some of the basic concepts
of writing TOAST reconstruction scripts in Matlab. This example has been kept
as simple as possible, to clarify the concepts without cluttering the code.
<ul>
<li>Reconstruction of a single parameter (absorption, &mu;) from a single
data type (log CW intensity measurements)
<li>No data noise
<li>No regularisation
<li>No rescaling of parameter or data vectors
</ul>
The reconstruction uses a Gauss-Newton solver, where the Hessian is inverted
with an implicit Krylov scheme. A line search is employed to find a minimum
of the objective function along the search direction at each iteration.

<h2>Loading the mesh</h2>
The mesh required by the FEM forward solver is loaded from file with the
toastReadMesh command:
<div class="code">
hMesh = <a href="toastReadMesh.html">toastReadMesh</a> (meshname);
</div>
The meshname parameter points to an ASCII file containing a mesh definition
in TOAST format. The return value is a handle that can be used to identify
the mesh in various TOAST functions. For example,
<div class="code">
n = <a href="toastMeshNodeCount.html">toastMeshNodeCount</a> (hMesh);
</div>
returns the number of nodes in the mesh.

<h2>Loading the source and detector definitions</h2>
The positions of sources and detectors on the mesh boundary, and their
connectivity is stored in a "QM" file (q=source, m=measurement). These
positions can be loaded into a mesh definition with
<div class="code">
<a href="toastReadQM.html">toastReadQM</a> (hMesh, qmname);
</div>
After the positions have been loaded into the mesh, the nodal source and
measurement vectors can be extracted with
<div class="code">
qvec = real(<a href="toastQvec.html">toastQvec</a> (hMesh, 'Neumann', 'Gaussian', 2));<br>
mvec = real(<a href="toastMvec.html">toastMvec</a> (hMesh, 'Gaussian', 2));
</div>
where 'Neumann' defines the sources in terms of a boundary flux, 'Gaussian'
defines the source and detector profiles, and '2' specifies the width.
The return values, qvec and mvec, are sparse matrices, where each column
represents a source or detector. In general they are complex-valued, but for
the CW problem considered here the imaginary part is not required.

<h2>Reading the measurement data</h2>
The measurement data contain the information used for reconstructing the
images of parameter distribution. They may be obtained from a data acquisition
system, or, as in this case, from an evaluation of the light transport
forward model of the target parameter distribution.
<div class="code">
data = <a href="toastReadRealVector.html">toastReadRealVector</a> (data_name);
</div>
The data vector contains the measurement data for all source-detector
combinations used. Its size must correspond to the information in the QM
file.
In this case, the measurements consist of only log amplitude data for a set
of CW measurements. For more general problems (e.g. to reconstruct the
scattering parameter as well), we would require frequency or time-of-flight
measurements.

<h2>Defining the initial parameter distribution</h2>
The reconstruction iteratively updates the current estimate of the
parameter distribution x. For the initial guess, we set homogeneous values
for absorption, scattering and refractive index:
<div class="code">
mua = ones(n,1) * 0.025;<br>
mus = ones(n,1) * 2;<br>
ref = ones(n,1) * refind;
</div>
Note that in this example only the absorption distribution is reconstructed.
The scattering and refractive index values don't change. They have been set
to the correct target parameters. In practice, any errors in these fixed
parameters would lead to errors in the absorption reconstruction due to
crosstalk.

<h2>The basis mapper</h2>
The forward solver operates on the basis expansion defined by the shape
functions of the finite element mesh, which is in general unstructured.
The reconstruction is normally performed on a regular pixel or voxel grid.
To map from one basis to the other, TOAST defines a mapping operator. An
instance of the mapper is generated with
<div class="code">
hBasis = <a href="toastSetBasis.html">toastSetBasis</a> (hMesh, grid);
</div>
where hMesh is the mesh handle defining the FEM basis, and grid is an
integer vector of length 2 or 3 defining the dimensions of the regular grid
for the inverse solver basis.
<p>If the outline of the reconstruction domain is irregular, not all the
pixels of an image defined in the regular grid may overlap with the domain.
These pixels do not appear in the solution vector. To map between a full
image and a masked image, a "solution mask" can be obtained with
<div class="code">
solmask = <a href="toastSolutionMask.html">toastSolutionMask</a> (hBasis);
</div>
This is a permutation vector of the size of a masked solution vector, with
each element representing an index of a pixel in the full image.

<p>Using the basis mapper handle, parameter distributions can now be mapped
from one basis to another, for example
<div class="code">
bcmua = <a href="toastMapMeshToBasis.html">toastMapMeshToBasis</a> (hBasis, mua * cm);
</div>
This maps the absorption distribution from a nodal representation into a
pixel image.
(note that TOAST uses parameter c&mu; for the reconstruction, where c is
the speed of light - this is the cm parameter in the line above).
<p>To strip the exterior pixels from the solution vector, the mask vector
is applied:
<div class="code">
scmua = bcmua(solmask);
</div>

<h2>The forward model</h2>
We are now in a position to evaluate the forward operator for a given
parameter distribution, to obtain model data of boundary measurements. In
this example, the forward operator is defined in a small local function:
<div class="code">
function proj = forwardModel(mua)<br>
smat = real(<a href="toastSysmat.html">toastSysmat</a> (hMesh, mua, mus, ref, 0));<br>
proj = reshape (log(mvec.' * (smat\qvec)), [], 1);<br>
end
</div>
toastSysmat constructs the FEM system matrix for a given set of nodal
parameters (mua, mus, and ref). The last parameter is the modulation frequency,
which is zero in this example.
<p>The next line solves the linear FEM system (smat\qvec) and applies the
boundary operator mvec. The measurements are then converted to log format
and stored in a linear vector.

<h2>The objective function</h2>
The objective function to be minimised by the Gauss-Newton solver is given
by the L2-norm of the data residual (the difference between measurement data
'data' and model data 'proj'). It is encoded in a local function:
<div class="code">
function of = objective(proj)<br>
of = sum((data-proj).^2);</br>
end
</div>

<h2>The Gauss-Newton loop</h2>
The reconstruction algorithm iteratively obtains updates x<sub>n+1</sub> from
the current estimate x<sub>n</sub> by solving
<div class="code">
x<sub>n+1</sub> = x<sub>n</sub> + H<sub>n</sub><sup>-1</sup> g<sub>n</sub>
</div>
where H = J<sup>T</sup>J is an approximation of the Hessian of the forward
operator, g = J<sup>T</sup>&Delta;y is the gradient, and J is the Jacobian.

<p>The Jacobian, dy<sub>i</sub>/dx<sub>j</sub> of the forward operator, can
be obtained by a call to toastJacobianCW:
<div class="code">
J = <a href="toastJacobianCW.html">toastJacobianCW</a> (hMesh, hBasis, qvec, mvec, mua, mus, ref, 'direct');
</div>
This returns a dense matrix of derivatives of log amplitude boundary data
with respect to perturbations in absorption. A more general version of this
function, toastJacobian, also includes blocks for the diffusion parameters
and phase data.

<p>The Jacobian is then rescaled so that the Hessian, J<sup>T</sup>J, has
an identity diagonal, to improve the conditioning of the problem:
<div class="code">
for i = 1:size(J,2)<br>
&nbsp;&nbsp;M(i) = 1 ./ sqrt(sum(J(:,i) .* J(:,i)));<br>
end<br>
for i = 1:size(M,2)<br>
&nbsp;&nbsp;J(:,i) = J(:,i) * M(1,i);<br>
end
</div>

<p>The gradient of the objective function is calculated by
<div class="code">
r = J' * (data-proj);
</div>

Given J and r, the Gauss-Newton step can now be solved with an implicit
Krylov solver, which in this example is implemented using the gmres
linear solver with a function pointer for obtaining matrix-vector
products:
<div class="code">
function dx = krylov(r)<br>
dx = gmres (@jtjx, r, 30, tolKrylov, 100);<br>
end
</div>
The jtjx callback function is given by
<div class="code">
function b = jtjx(x)<br>
b = J' * (J*x);<br>
end
</div>

<p>After obtaining a new search direction with the Krylov solver, an inexact
line search along this direction is applied to find an update:
<div class="code">
[step, err] = <a href="toastLineSearch.html">toastLineSearch</a> (x, dx, step, err, @objective2);
</div>
Here, "objective2" is a callback function which returns the objective
function for a given parameter vector. It is implemented in a local function:
<div class="code">
function of = objective2(x)<br>
smua = x/cm;<br>
if min(smua) &lt; 0<br>
&nbsp;&nbsp;of = 1e8;<br>
else<br>
&nbsp;&nbsp;mua = toastMapSolToMesh (hBasis, smua);<br>
&nbsp;&nbsp;of = objective(forwardModel(mua));<br>
end<br>
end
</div>
where we also try to discourage negative solutions. (Note that positivity
can be enforced by reconstructing for logarithmic parameters, demonstrated
in a subsequent tutorial.)

<p>Finally, the solution vector is updated:
<div class="code">
x = x + dx*step;
</div>
Projection, objective function and nodal parameters are updated, and the
current solution is displayed.

<p>The Gauss-Newton step is repeated until one of the termination conditions
is satisfied.

</div>
</body>
</html>
