<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                            
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                            
  <meta name="GENERATOR"
 content="Mozilla/4.61 [en] (X11; I; Linux 2.2.12-20smp i686) [Netscape]">
                            
  <meta name="Author" content="Martin Schweiger">
  <title>TOAST Optical Tomography Home Page</title>
  <link rel="stylesheet" href="../../toast.css" type="TEXT/CSS">  
</head>

<body text="#000000" bgcolor="#ffffff" link="#0000ff" vlink="#990066"
 alink="#ff0000">
<div class="all">
<table class="header">
<tr><td class="logo" rowspan="2"><img src="../../images/toast_logo_small.jpg"></td>
<td><img src="../../images/toastpp_label.png" width="300" height="46"></td></tr>
<tr><td>Image Reconstruction in Diffuse Optical Tomography</td></tr>
</table>

<div class="menu">
  <dl>
    <dt><a href="../demos_matlab.html">Tutorials</a></dt>
  </dl>
</div>

<table class="main">
<tr>
<td class="maintext">
<h1>Toast toolbox tutorial: Generating time domain data</h1>
<p>In this tutorial we simulate the data generated by a time-domain DOT data acqusition system. In time-domain systems, the sources are short laser pulses in the picosecond range, and the temporal profile of the transmitted light is measured with time-resolved detectors.
To run this tutorial yourself, you need Matlab, and you have to install the Toast toolbox on your computer.</p>
<p>To save you typing, the full Matlab script for this example can be downloaded <a href="demo_matlab_fwd4.m">here</a>.

<h2>Step 1: Setting up the time domain system matrix</h2>
<p>The time-domain version of the diffusion equation is given by</p>
<img src="demo_matlab_fwd4_eq1.png" />
<p>where <i>&phiv;</i> is the real-valued photon density depending on position and time. In contrast to the steady-state problem of <a href="demo_matlab_fwd1.html">Tutorial 1</a>, this PDE contains a time derivative of the photon density. We will approximate this by a finite difference scheme in time.</p>
<p>The discretised version of the PDE is given by</p>
<img src="demo_matlab_fwd4_eq2.png" />
<p>where K is the same stiffness matrix as for the steady-state problem, and M is the mass matrix.
By approximating the derivative with a forward difference at time <i>n</i> and a backward difference at time <i>n</i>+1 and employing a trapezoid integration rule, we get</p>
<img src="demo_matlab_fwd4_eq3.png" />
<p>where parameter <i>&theta;</i> controls the coupling of adjacent time steps. Typical values are 0 (explicit scheme), 1 (implicit scheme), and 1/2 (Crank-Nicholson).</p>
<p>After setting up the Toast code identically to <a href="demo_matlab_fwd1.html">Tutorial 1</a> (or <a href="demo_matlab_fwd2.html">Tutorial 2</a> for the inhomogeneous problem), up to computation of the stiffness matrix using the dotSysmat call, we now need to compute the mass matrix:</p>
<div class="example">
M = mesh.Massmat;
</div>


<h2>Step 2: Discrete integration in time</h2>
<p>Assuming constant time steps &Delta;t, and initial conditions &Phi;<sub>0</sub> = 0, Q<sub>0</sub> &gt; 0, Q<sub>n</sub> = 0 (n &gt; 0), we can write</p>
<div class="example">
dt = 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">% step size [ps]</span><br />
nstep = 1000;&nbsp;<span class="comment">% number of time steps</span><br />
theta = 0.5;&nbsp;&nbsp;<span class="comment">% Crank-Nicholson</span><br />
K0 = -(K * (1-theta) - M * 1/dt);  <span class="comment">% matrix for step n</span><br />
K1 = K * theta + M * 1/dt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">% matrix for step n+1</span><br />
q = qvec/dt;&nbsp;&nbsp;<span class="comment">% source at n=0</span><br />
phi = K1\q;&nbsp;&nbsp;&nbsp;<span class="comment">% Phi_1</span><br />
gamma(1,:) = mvec.' * phi;  <span class="comment">% project to boundary measurements</span><br />
for i=2:nstep  <span class="comment">% loop over remaining steps</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;q = K0 * phi;<br />
&nbsp;&nbsp;&nbsp;&nbsp;phi = K1\q;<br />
&nbsp;&nbsp;&nbsp;&nbsp;gamma(i,:) = mvec.' * phi;<br />
end
</div>
<p>This will generate the temporal response function for each measurement at all time steps in matrix gamma.</p>
<p>Note that the solution of the linear system, phi = K1\q, at each time step can be time-consuming. It is generally more efficient to perform a LU-decomposition of K1 so that in the loop only a substitution using the two triangular matrices is required:</p>
<div class="example">
[L,U] = lu(K1);<br />
for i=2:nstep<br />
&nbsp;&nbsp;&nbsp;&nbsp;q = K0 * phi;<br />
&nbsp;&nbsp;&nbsp;&nbsp;phi = U\(L\q);<br />
&nbsp;&nbsp;&nbsp;&nbsp;gamma(i,:) = mvec.' * phi;<br />
end
</div>
<p>Where memory constraints and the size of the problem do not allow the use of a direct solver, the backslash operator must be replaced with an iterative solver, such as gmres or cg. In that case, it is important to use a preconditioner, such as incomplete LU factorisation (ilu), to be computed before entering the loop.</p>
<img src="demo_matlab_fwd4_1.png" />

</td>
</tr>
</table>

<div class="footer"><hr />
<table>
<tr><td>
Page last updated: 28 July 2016 by <a href="http://www.medphys.ucl.ac.uk/%7Emartins">Martin Schweiger</a></td></tr>
</table>
</div>

</div> 

</body>
</html>
