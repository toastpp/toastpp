<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                            
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                            
  <meta name="GENERATOR"
 content="Mozilla/4.61 [en] (X11; I; Linux 2.2.12-20smp i686) [Netscape]">
                            
  <meta name="Author" content="Martin Schweiger">
  <title>TOAST Optical Tomography Home Page</title>
  <link rel="stylesheet" href="../../toast.css" type="TEXT/CSS">  
</head>

<body text="#000000" bgcolor="#ffffff" link="#0000ff" vlink="#990066"
 alink="#ff0000">
<div class="all">
<table class="header">
<tr><td class="logo" rowspan="2"><img src="../../images/toast_logo_small.jpg"></td>
<td><img src="../../images/toastpp_label.png" width="300" height="46"></td></tr>
<tr><td>Image Reconstruction in Diffuse Optical Tomography</td></tr>
</table>

<div class="menu">
  <dl>
    <dt><a href="../demos_matlab.html">Tutorials</a></dt>
  </dl>
</div>

<table class="main">
<tr>
<td class="maintext">
<h1>A simple reconstruction example</h1>
<p>In this example, we reconstruct the absorption distribution inside a circular domain from steady-state boundary data. The complete Matlab script for this tutorial can be found <a href="demo_matlab_rec1.m">here</a>.</p>

<h2>Step 1: Generating the forward data</h2>
<p>Note: In a real-life application, the forward data would be generated by the measurement instrument. In this example, we substitute the measurement with a simulation.</p>
<p> This follows the forward solution shown in <a href="demo_matlab_fwd2.html">Tutorial 2</a>, but for this first reconstruction example we only use a target image for the absorption distribution, while keeping the scattering coefficient constant.</p>
<p>Load the target grayscale bitmap, and scale it to the desired absorption coefficients:</p>
<div class="example">
bmua_tgt = imread('demo_matlab_fwd2_mua.png');<br />
bmua_tgt = double(bmua_tgt)./255.*0.02 + 0.01;
</div>
<p>Create a circular FEM mesh for the forward calculation:</p>
<div class="example">
rad = 25;<br />
[vtx,idx,eltp] = mkcircle(rad,6,64,4);<br />
fwdmesh = toastMesh(vtx,idx,eltp);<br />
</div>
<p>Map the target parameter distribution to nodal coefficients, using a basis mapper object:</p>
<div class="example">
fwdgrd = size(bmua_tgt);<br />
fwdbasis = toastBasis(fwdmesh,fwdgrd);<br />
mua = fwdbasis.Map('B->M',bmua_tgt);<br />
mus = ones(size(mua))*2.0;
</div>
<p> We assume a homogeneous value for the refractive index of the scattering medium:</p>
<div class="example">
refind = 1.4;
c0 = 0.3; <span class="comment">% speed of light in vacuum [mm/ps]</span><br />
c = c0/refind; <span class="comment">% speed of light in the medium</span><br />
ref = ones(size(mua))*refind; <span class="comment">% refractive index in FEM basis</span><br />
</div>
<p>Compute source and measurement vectors:</p>
<div class="example">
nq = 16;<br />
for i=1:nq<br />
&nbsp;&nbsp;phi_q = 2*pi*(i-1)/nq;<br />
&nbsp;&nbsp;Q(i,:) = rad * [cos(phi_q) sin(phi_q)];<br />
&nbsp;&nbsp;phi_m = 2*pi*(i-0.5)/nq;<br />
&nbsp;&nbsp;M(i,:) = rad * [cos(phi_m) sin(phi_m)];<br />
end<br />
fwdmesh.SetQM(Q,M);<br />
qvec = real(fwdmesh.Qvec('Neumann','Gaussian',2));<br />
mvec = real(fwdmesh.Mvec('Gaussian',2,ref));
</div>
<p>Compute the stiffness matrix for the steady-state diffusion problem and solve the linear FEM system:</p>
<div class="example">
K = dotSysmat(fwdmesh,mua,mus,ref,0);<br />
Phi = K\qvec;<br />
Y = mvec.' * Phi;
</div>
<p>We now map the forward data to log:</p>
<div class="example">
data = reshape(log(Y), [], 1);
</div>
<p><i>data</i> is the log amplitude of the transmitted modulation signal for the steady-state problem considered in this example. Later examples will also cover frequency and time-domain problems.</p>

<h2>Setting up the inverse solver</h2>
<p>We first set up a mesh for the FEM solver. In principle, we could use the same mesh we used for the forward data generation in Step 1. However, to avoid an <i>inverse crime</i>, let's create a different, coarser mesh:</p>
<div class="example">
[vtx,idx,eltp] = mkcircle(rad,6,32,2);<br />
mesh = toastMesh(vtx,idx,eltp);<br />
n = mesh.NodeCount;
</div>
<p>We also define a separate basis to express the reconstructed coefficients in. Toast supports a number of different basis types. Here, we use the default basis of a regular pixel basis with bi-linear basis functions:</p>
<div class="example">
grd = [32,32];<br />
basis = toastBasis(mesh,grd);
</div>
<p>Now set up the initial guess for the coefficients (absorption, scattering and refractive index). In this case, we apply homogeneous parameter distributions:</p>
<div class="example">
mua = ones(n,1)*0.01;<br />
mus = ones(n,1)*1;<br />
ref = ones(n,1)*1.4;
</div>
<p>Define the source and measurement vectors for the inverse solver mesh:</p>
<div class="example">
mesh.SetQM(Q,M);<br />
qvec = mesh.Qvec('Neumann','Gaussian',2);<br />
mvec = mesh.Mvec('Gaussian',2,ref);
</div>
<p>Compute the forward solution for these coefficients:</p>
<div class="example">
K = dotSysmat(mesh,mua,mus,ref,0);<br />
proj = reshape(log(mvec.' * (K\qvec)), [], 1);
</div>
<p>We also need to define a data scaling vector for computation of the objective function. This will become important when using multiple data types (such as log amplitude and phase). For now, a unity dummy vector is sufficient:</p>
<div class="example">
sd = ones(size(proj));
</div>
<p>Set up the <i>solution vector</i> x of the unknowns we want to reconstruct. In this simple example, we only reconstruct for absorption values, assuming the scattering coefficient to be known. Toast internally operates with the coefficients multiplied with the speed of light (c*mua), so we include that in the solution values. We also want to reconstruct for the log of the mua values, so we perform a parameter transformation to logx:</p>
<div class="example">
c = 0.3./ref; <span class="comment">% speed of light in the medium [mm/ps]</span><br />
x = basis.Map('M->S', mua.*c); <span class="comment">% Map from mesh to inverse basis</span><br />
logx = log(x);
</div>
</p>
<p>Compute the <i>objective function</i> for the initial parameter estimate:</p>
<div class="example">
err0 = objective(data,proj);<br />
err = err0;<br />
errp = inf;
</div>
<p>where <i>objective</i> is an inline function computing the L2-norm of the difference between the measurements and forward model:</p>
<div class="example">
function of = objective(data,proj)<br />
of = sum((data-proj).^2);<br />
end
</div>

<h2>The iterative inverse solver loop</h2>
<p>In the solver loop we use a nonlinear conjugate gradient approach to iteratively minimise the objective function. The loop terminates when one of the stopping criteria is satisfied:</p>
<div class="example">
tolcg = 1e-6; <span class="comment">% NCG convergence criterion</span><br />
resetcg = 20; <span class="comment">% NCG reset interval</span><br />
step = 1; <span class="comment">% initial line search step</span><br />
itrmax = 100; <span class="comment">% max. number of iterations</span><br />
itr = 1; <span class="comment">% initialise iteration counter</span><br />
<br />
while (itr <= itrmax) && (err > tolcg*err0) && (errp-err > tolcg)<br />
&nbsp;&nbsp;errp = err; <span class="comment">% store previous objective value</span><br />
&nbsp;&nbsp;<span class="comment">% body of solver loop to go here</span><br />
end
</div>
<p>In the body of the solver loop, we first compute the gradient of the objective function with respect to the coefficients, using the <i>toastGradient</i> function:</p>
<div class="example">
r = -toastGradient (mesh, basis, qvec, mvec, mua, mus, ref, 0, ...<br />
data, sd, 'method', 'direct');<br />
r = r(1:basis.slen);
</div>
<p>Note that toastGradient returns the gradient both with respect to absorption and diffusion coefficient. Since in this example we only reconstruct for absorption, we only use the first part of r (1:basis.slen), where basis.slen is the length of the solution vector for a single coefficient.</p>
<p>Because we are reconstructing log coefficients, we have to modify the gradient using the chain rule:</p>
<div class="example">
r = r .* x;
</div>
<p>Now compute an update direction using the nonlinear conjugate gradient method:</p>
<div class="example">
if itr > 1<br />
&nbsp;&nbsp;delta_old = delta_new;<br />
&nbsp;&nbsp;delta_mid = r' * s;<br />
end<br />
s = r;<br />
if itr == 1<br />
&nbsp;&nbsp;d = s;<br />
&nbsp;&nbsp;delta_new = r' * d;<br />
else<br />
&nbsp;&nbsp;delta_new = r' * s;<br />
&nbsp;&nbsp;beta = (delta_new - delta_mid) / delta_old;<br />
&nbsp;&nbsp;if mod (itr,resetcg) == 0 || beta <= 0<br />
&nbsp;&nbsp;&nbsp;&nbsp;d = s; <span class="comment">% reset CG</span><br />
&nbsp;&nbsp;else<br />
&nbsp;&nbsp;&nbsp;&nbsp;d = s + d*beta;<br />
&nbsp;&nbsp;end<br />
end
</div>
<p>where the step direction is reset to the gradient direction in regular intervals (resetcg) or when the conjugate gradient update fails (beta &leq; 0).</p>
<p>We now perform a one-dimensional inexact line search in direction <i>d</i>, using the <i>toastLineSearch</i> function:</p>
<div class="example">
step = toastLineSearch (logx, d, step, err, @ls_objective);
</div>
<p>where <i>ls_objective</i> is a callback function invoked by toastLineSearch whenever the objective function of a trial step needs to be computed. The callback function expects a single argument (the solution vector) and must return a scalar (the objective function). We define it as an inline function as follows:</p>
<div class="example">
function p = ls_objective(logx)<br />
&nbsp;&nbsp;mua_ = basis.Map('S->M', exp(logx)) ./ c;<br />
&nbsp;&nbsp;K_ = dotSysmat(mesh,mua_,mus,ref,0);<br />
&nbsp;&nbsp;proj_ = reshape(log(mvec.' * (K_\qvec)), [], 1);<br />
&nbsp;&nbsp;of = objective(data,proj_);<br />
end
</div>
<p>Now apply the update to the solution vector:</p>
<div class="example">
logx = logx + d*step<br />
x = exp(logx);
</div>
<p>Convert to absorption values, and map back to the FEM basis:</p>
<div class="example">
mua = basis.Map('S->M', smua) ./ c;
</div>
<p>Finally, display the current solution. For this, we map mua to a dense regular grid. Note that this is slightly different to the solution vector, which doesn't contain the pixels without support in the mesh domain. This is done with the help of the <i>Map</i> method of the basis mapper object, where 'S' refers to the inverse solution basis, and 'B' refers to a grid basis covering the full bounding box.</p>
<div class="example">
mua_img = reshape (basis.Map('S->B', mua), grd);<br />
imagesc(mua_img,[0.005,0.03]);<br />
axis equal tight; colorbar
</div>
<img src="demo_matlab_rec1_1.png" />

</td>
</tr>
</table>

<div class="footer"><hr />
<table>
<tr><td>
Page last updated: 28 July 2016 by <a href="http://www.medphys.ucl.ac.uk/%7Emartins">Martin Schweiger</a></td></tr>
</table>
</div>

</div> 

</body>
</html>
