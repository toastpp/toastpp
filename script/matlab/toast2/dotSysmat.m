function [S,B,alpha] = dotSysmat (hmesh,mua,mus,ref,varargin)
% Generate an FEM system matrix for solving the discretised diffusion
% equation in frequency DOT.
%
% Syntax: S = dotSysmat (mesh, mua, mus, ref)
%         S = dotSysmat (..., freq);
%         S = dotSysmat (..., 'EL')
%         [S,B] = dotSysmat (...)
%         [S,B,alpha] = dotSysmat (...)
%
% Parameters:
%         mesh [object]:
%             toastMesh object
%         mua [real column vector]:
%             nodal absorption coefficient [1/mm]
%         mus [real column vector]:
%             nodal reduced scattering coefficient [1/mm]
%         ref [real column vector]:
%             nodal refractive index
%         freq [real scalar]:
%             modulation frequency [MHz]
%         'EL'
%             flag to indicate element basis
%
% Return values:
%         S [real or complex sparse matrix n x n]:
%             system matrix
%         B [real sparse matrix n x n]:
%             boundary part of the system matrix
%         alpha [real vector n]:
%             boundary pre-factors, containing refractive index mismatch
%             information
%
% Notes:  This is a convenience function for DOT problems, which removes
%         the need for multiple calls to toastMesh.SysmatComponent for
%         assembling the components of the DOT diffusion forward model.
%
%         It returns a sparse n x n matrix (n: number of nodes in the
%         mesh) containing system matrix S. S is the sum of four
%         components: an absorption-dependent real matrix of products of
%         shape functions, a diffusion-dependent real matrix of products of
%         shape function derivatives, a component incorporating the Robin
%         boundary condition (including any refractive index mismatch at
%         the tissue-air interface) and a frequency-dependent imaginary
%         matrix representing the frequency modulation term.
%
%         Note that omitting the freq parameter, or setting freq=0 reverts
%         to the DC case. In this case the returned matrix is real.
%
%         If the 'EL' flag is present, the system matrix is calculated on
%         an element basis, rather than a node basis. Length 'n' of all
%         parameter vectors in that case must be equal to the number of
%         elements. Parameters are considered constant over each element,
%         so parameter distribution has discontinuities at element
%         boundaries.
%
%         If B is provided as an output argument, it is filled with the
%         boundary component of the system matrix (but without the
%         refractive index mismatch prefactor). The sparsity structure of B
%         is the same as S.
%
%         If alpha is provided as an output argument, it is filled with the
%         boundary mismatch prefactors. (returned as a vector of size n).
%
% Examples:
%         A. Load a mesh and an associated source/detector definition file,
%         allocate homogeneous optical coefficients and solve for the
%         fields generated by each source.
%
%         mesh = toastMesh('circle.msh');
%         mesh.ReadQM('circle.qm');
%         n = mesh.NodeCount;
%         mua = ones(n,1)*0.01;   % absorption coefficient [1/mm]
%         mus = ones(n,1)*1;      % scattering coefficient [1/mm]
%         ref = ones(n,1)*1.4;    % refractive index
%         freq = 100;             % modulation frequency [MHz]
%         S = dotSysmat(mesh,mua,mus,ref,freq);
%         Q = mesh.Qvec('Neumann','Gaussian',2);
%         phi = S\Q;
%
%         B. Re-implement dotSysmat with lower-level Toast functions.
%
%         mesh = toastMesh('circle.msh');
%         n = mesh.NodeCount;
%         mua = ones(n,1)*0.01;   % absorption coefficient [1/mm]
%         mus = ones(n,1)*1;      % scattering coefficient [1/mm]
%         kap = 1./(3*(mua+mus)); % diffusion coefficient [mm]
%         ref = ones(n,1)*1.4;    % refractive index
%         c0 = 0.3;               % speed of light in vacuum [mm/ps]
%         c = c0./ref;            % speed of light in the medium
%         freq = 100;             % modulation frequency [MHz]
%         omega = 2*pi*1e-6;      % modulation frequency [cycles/ps]
%         [S B alpha] = dotSysmat(mesh,mua,mus,ref,freq);
%         % Now build S from individual components
%         S1 = mesh.SysmatComponent('PFF',mua.*c);  % absorption term
%         S2 = mesh.SysmatComponent('PDD',kap.*c);  % diffusion component
%         S3 = mesh.SysmatComponent('BndPFF',c./(2*alpha)); % boundary term
%         S4 = mesh.SysmatComponent('FF')*omega;
%         S_manual = S1 + S2 + S3 + 1i*S4;
%
%         Note that internally, Toast operates with optical parameters
%         multiplied by the speed of light, so the above example does the
%         same to allow direct comparison of the generated matrices.
%
%         The example is cheating somewhat by using the 'alpha' boundary
%         term returned by dotSysmat for constructing component S3, but the
%         boundary term could also be calculated directly in Matlab (it
%         would just make the example a bit cumbersome to read).
%
% See also:
%         toastMesh, toastMesh.SysmatComponent, toastMesh.Massmat, toastMesh.Elmat

freq = 0;
elbasis = false;

for i=5:nargin
    arg = varargin{i-4};
    if isnumeric(arg)
        freq = arg;
    elseif ischar(arg) && strcmpi(arg,'el')
        elbasis = true;
    end
end

if elbasis

if nargout < 2
    S = toastmex(uint32(23),hmesh.handle,double(mua),double(mus),double(ref),freq,'EL');
elseif nargout < 3
    [S,B] = toastmex(uint32(23),hmesh.handle,double(mua),double(mus),double(ref),freq,'EL');
else
    [S,B,alpha] = toastmex(uint32(23),hmesh.handle,double(mua),double(mus),double(ref),freq,'EL');
end

else
    
if nargout < 2
    S = toastmex(uint32(23),hmesh.handle,double(mua),double(mus),double(ref),freq);
elseif nargout < 3
    [S,B] = toastmex(uint32(23),hmesh.handle,double(mua),double(mus),double(ref),freq);
else
    [S,B,alpha] = toastmex(uint32(23),hmesh.handle,double(mua),double(mus),double(ref),freq);
end

end

end
